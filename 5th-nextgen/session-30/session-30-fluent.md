# Type Hints in Functions  

Type hints are the biggest change in the history of Python since the unification of
types and classes in Python 2.2, released in 2001. However, type hints do not benefit
all Python users equally. That’s why they should always be optional.  
PEP 484—Type Hints introduced syntax and semantics for explicit type declarations
in function arguments, return values, and variables. The goal is to help developer
tools find bugs in Python codebases via static analysis, i.e., without actually running
the code through tests.  

## About Gradual Typing  

### A gradual type system:  
**Is optional**  
By default, the type checker should not emit warnings for code that has no type
hints. Instead, the type checker assumes the Any type when it cannot determine
the type of an object. The Any type is considered compatible with all other types.  
**Does not catch type errors at runtime**  
Type hints are used by static type checkers, linters, and IDEs to raise warnings.
They do not prevent inconsistent values from being passed to functions or
assigned to variables at runtime.  
**Does not enhance performance**  
Type annotations provide data that could, in theory, allow optimizations in the
generated bytecode, but such optimizations are not implemented in any Python
runtime that I am aware in of July 2021.

## Gradual Typing in Practice  

Let’s see how gradual typing works in practice, starting with a simple function and
gradually adding type hints to it, guided by Mypy.  
We will annotate a show_count function that returns a string with a count and a sin‐
gular or plural word, depending on the count:

```python
>>> show_count(99, 'bird')
'99 birds'
>>> show_count(1, 'bird')
'1 bird'
>>> show_count(0, 'bird')
'no birds'
```
show_count from messages.py without type hints:

```python
def show_count(count, word):
    if count == 1:
        return f'1 {word}'
    count_str = str(count) if count else 'no'
    return f'{count_str} {word}s'
```

## Starting with Mypy  
Now I can gradually add type hints function by function, without getting warnings
about functions that I haven’t annotated. This is a fully annotated signature that satis‐
fies Mypy:  

```python
def show_count(count: int, word: str) -> str:
```
The show_count function in Example only works with regular nouns. If the plural
can’t be spelled by appending an 's', we should let the user provide the plural form,
like this:  

```python
>>> show_count(3, 'mouse', 'mice')
'3 mice'
```

**showcount from hints_2/messages.py with an optional parameter:**  
```python
def show_count(count: int, singular: str, plural: str = '') -> str:
    if count == 1:
        return f'1 {singular}'
    count_str = str(count) if count else 'no'
    if not plural:
        plural = singular + 's'
    return f'{count_str} {plural}'
```
Now Mypy reports “Success.”

## Using None as a Default  

In the Example, the parameter plural is annotated as str, and the default value is ' ',
so there is no type conflict. I like that solution, but in other contexts None is a better default. If the optional
parameter expects a mutable type, then None is the only sensible default.

### Note:
To have None as the default for the plural parameter, here is what the signature
would look like:  

```python
from typing import Optional

def show_count(count: int, singular: str, plural: Optional[str] = None) -> str:
```
Let’s unpack that:  
* Optional[str] means plural may be a str or None.
* You must explicitly provide the default value = None.

If you don’t assign a default value to plural, the Python runtime will treat it as a
required parameter. Remember: at runtime, type hints are ignored.  

### Duck typing  
The view adopted by Smalltalk—the pioneering object-oriented language—as
well as Python, JavaScript, and Ruby. Objects have types, but variables (including parameters) are untyped. In practice, it doesn’t matter what the declared type of
the object is, only what operations it actually supports. If I can invoke
*birdie.quack()*, then birdie is a duck in this context.

### Nominal typing  
The view adopted by C++, Java, and C#, supported by annotated Python. Objects
and variables have types. But objects only exist at runtime, and the type checker
only cares about the source code where variables (including parameters) are
annotated with type hints.  














